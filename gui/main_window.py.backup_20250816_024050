import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, simpledialog
from tkcalendar import DateEntry
from datetime import datetime, date
import sys
import os

# Agregar el directorio ra√≠z al path para importaciones
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database.database_manager import DatabaseManager
from gui.themes.corporate_colors import CorporateColors
from utils.helpers import (
    get_default_machines, get_lines_list, get_machines_by_line,
    validate_observation, validate_machine,
    get_today_date, format_date_for_display, get_current_user,
    get_filter_options, calculate_date_range, filter_dates_in_range, get_date_range_description
)
from version import get_full_version_string, get_version_string

class MainWindow:
    """Ventana principal de la aplicaci√≥n de observaciones de m√°quinas"""
    
    def __init__(self, user_name=None, user_role=None):
        self.root = tk.Tk()
        self.user_name = user_name or "Usuario"
        self.user_role = user_role or "operador"
        self.colors = CorporateColors()
        self.db_manager = DatabaseManager()
        self.logout_callback = None
        
        # Definir permisos por rol
        self.user_permissions = {
            'admin': {'can_delete': True, 'can_edit': True, 'can_configure': True, 'can_view_all': True},
            'administrador': {'can_delete': True, 'can_edit': True, 'can_configure': True, 'can_view_all': True},
            'supervisor': {'can_delete': False, 'can_edit': True, 'can_configure': True, 'can_view_all': True},
            'operador': {'can_delete': False, 'can_edit': False, 'can_configure': False, 'can_view_all': False},
            'tecnico': {'can_delete': False, 'can_edit': True, 'can_configure': False, 'can_view_all': True},
            'invitado': {'can_delete': False, 'can_edit': False, 'can_configure': False, 'can_view_all': False}
        }
    
    def set_logout_callback(self, callback):
        """Establece el callback para logout"""
        self.logout_callback = callback
        
    def get_screen_dimensions(self):
        """Obtiene las dimensiones de la pantalla"""
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        return screen_width, screen_height
    
    def calculate_window_size(self, width_percent, height_percent, min_width, min_height, max_width=None, max_height=None):
        """Calcula el tama√±o de ventana basado en porcentajes de pantalla"""
        screen_width, screen_height = self.get_screen_dimensions()
        
        # Calcular tama√±o proporcional
        calc_width = int(screen_width * width_percent)
        calc_height = int(screen_height * height_percent)
        
        # Aplicar l√≠mites m√≠nimos
        calc_width = max(calc_width, min_width)
        calc_height = max(calc_height, min_height)
        
        # Aplicar l√≠mites m√°ximos si se especifican
        if max_width:
            calc_width = min(calc_width, max_width)
        if max_height:
            calc_height = min(calc_height, max_height)
            
        return calc_width, calc_height
    
    def center_window(self, window, width, height):
        """Centra una ventana en la pantalla"""
        screen_width, screen_height = self.get_screen_dimensions()
        pos_x = (screen_width - width) // 2
        pos_y = (screen_height - height) // 2
        window.geometry(f"{width}x{height}+{pos_x}+{pos_y}")

    def show(self):
        """Muestra la ventana principal"""
        # Configurar ventana
        self.root.title(f"üìä Observaciones de M√°quinas - {get_full_version_string()} - Usuario: {self.user_name} ({self.get_role_display_name(self.user_role)})")
        
        # MAXIMIZAR AL 100% INMEDIATAMENTE
        self.root.state('zoomed')  # Maximizaci√≥n real en Windows
        
        # Configurar tama√±o m√≠nimo para cuando se desmaximice
        self.root.minsize(1000, 600)
        
        # Permitir redimensionamiento (responsive)
        self.root.resizable(True, True)
        
        # Configurar el cierre de ventana
        self.root.protocol("WM_DELETE_WINDOW", self.on_window_close)
        
        # Configurar colores de fondo
        self.root.configure(bg=self.colors.BACKGROUND_PRIMARY)
        
        # Crear interfaz
        self.create_interface()
        
        # Configurar men√∫
        self.setup_menu()
        
        # Cargar observaciones del d√≠a
        self.load_today_observations()
        
        # Mostrar mensaje de bienvenida
        self.root.after(500, self.show_welcome_message)
        
        # Iniciar loop principal
        self.root.mainloop()
    
    def create_interface(self):
        """Crea la interfaz principal"""
        # Frame principal
        main_frame = tk.Frame(self.root, bg=self.colors.BACKGROUND_PRIMARY)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Crear secciones
        self.create_header(main_frame)
        self.create_user_bar(main_frame)
        self.create_main_content(main_frame)
        self.create_footer(main_frame)
    
    def create_header(self, parent):
        """Crea el encabezado de la aplicaci√≥n"""
        header_frame = tk.Frame(parent, bg=self.colors.CORPORATE_GOLD, height=80)
        header_frame.pack(fill=tk.X, padx=10, pady=(5, 0))
        header_frame.pack_propagate(False)
        
        # Contenido del header
        content_frame = tk.Frame(header_frame, bg=self.colors.CORPORATE_GOLD)
        content_frame.pack(expand=True, fill=tk.BOTH, padx=20, pady=10)
        
        # T√≠tulo principal
        title_label = tk.Label(content_frame, 
                              text="üè≠ Sistema de Observaciones de M√°quinas",
                              font=("Arial", 18, "bold"),
                              fg=self.colors.TEXT_ON_GOLD,
                              bg=self.colors.CORPORATE_GOLD)
        title_label.pack(side=tk.LEFT)
        
        # Informaci√≥n de versi√≥n
        version_label = tk.Label(content_frame,
                                text=get_full_version_string(),
                                font=("Arial", 10),
                                fg=self.colors.TEXT_ON_GOLD,
                                bg=self.colors.CORPORATE_GOLD)
        version_label.pack(side=tk.RIGHT, anchor=tk.E)
    
    def create_user_bar(self, parent):
        """Crea la barra de usuario"""
        user_frame = tk.Frame(parent, bg=self.colors.SURFACE_LIGHT, height=40)
        user_frame.pack(fill=tk.X, pady=(5, 0))
        user_frame.pack_propagate(False)
        
        # Contenido de la barra de usuario
        content_frame = tk.Frame(user_frame, bg=self.colors.SURFACE_LIGHT)
        content_frame.pack(expand=True, fill=tk.BOTH, padx=15, pady=5)
        
        # Informaci√≥n del usuario (clickeable)
        user_info = f"{self.get_user_icon(self.user_role)} {self.user_name} ({self.get_role_display_name(self.user_role)})"
        user_button = tk.Button(content_frame, text=user_info,
                               font=("Arial", 11, "bold"),
                               fg=self.colors.TEXT_PRIMARY,
                               bg=self.colors.SURFACE_LIGHT,
                               relief=tk.FLAT,
                               cursor="hand2",
                               command=self.show_user_profile)
        user_button.pack(side=tk.LEFT)
        
        # Fecha actual
        today_label = tk.Label(content_frame,
                              text=f"üìÖ {format_date_for_display(get_today_date())}",
                              font=("Arial", 11),
                              fg=self.colors.TEXT_PRIMARY,
                              bg=self.colors.SURFACE_LIGHT)
        today_label.pack(side=tk.RIGHT)
    
    def create_main_content(self, parent):
        """Crea el contenido principal"""
        content_frame = tk.Frame(parent, bg=self.colors.BACKGROUND_PRIMARY)
        content_frame.pack(fill=tk.BOTH, expand=True, pady=(10, 5))
        
        # Frame de botones
        button_frame = tk.Frame(content_frame, bg=self.colors.BACKGROUND_PRIMARY)
        button_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Bot√≥n Nueva Observaci√≥n
        new_button = tk.Button(button_frame, text="‚ûï Nueva Observaci√≥n",
                              command=self.show_new_incident_dialog,
                              bg=self.colors.BUTTON_PRIMARY,
                              fg=self.colors.TEXT_ON_GOLD,
                              font=("Arial", 11, "bold"),
                              padx=20, pady=8)
        new_button.pack(side=tk.LEFT, padx=(0, 10))
        
        # Bot√≥n Actualizar
        refresh_button = tk.Button(button_frame, text="üîÑ Actualizar Observaciones",
                                  command=self.load_today_observations,
                                  bg=self.colors.BUTTON_SECONDARY,
                                  fg=self.colors.TEXT_ON_GOLD,
                                  font=("Arial", 11, "bold"),
                                  padx=20, pady=8)
        refresh_button.pack(side=tk.LEFT, padx=(0, 10))
        
        # Bot√≥n Ver Lista Completa
        list_button = tk.Button(button_frame, text="üìã Ver Lista Completa",
                               command=self.show_complete_list,
                               bg="#4299e1",
                               fg="white",
                               font=("Arial", 11, "bold"),
                               padx=20, pady=8)
        list_button.pack(side=tk.LEFT, padx=(0, 10))
        
        # Bot√≥n Configuraci√≥n (solo para roles con permisos)
        if self.user_permissions[self.user_role]['can_configure']:
            config_button = tk.Button(button_frame, text="‚öôÔ∏è Configuraci√≥n",
                                     command=self.show_config,
                                     bg="#805ad5",
                                     fg="white",
                                     font=("Arial", 11, "bold"),
                                     padx=20, pady=8)
            config_button.pack(side=tk.LEFT)
        
        # Frame para la tabla
        table_frame = tk.Frame(content_frame, bg=self.colors.BACKGROUND_PRIMARY)
        table_frame.pack(fill=tk.BOTH, expand=True)
        
        # Crear Treeview para mostrar observaciones
        columns = ('ID', 'Fecha', 'Hora', 'L√≠nea', 'M√°quina', 'Subcategor√≠a', 'Observaciones', 'Usuario', 'Rol')
        self.observations_tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=15)
        
        # Configurar columnas
        column_widths = {
            'ID': 50,
            'Fecha': 100,
            'Hora': 80,
            'L√≠nea': 80,
            'M√°quina': 100,
            'Subcategor√≠a': 120,
            'Observaciones': 300,
            'Usuario': 100,
            'Rol': 100
        }
        
        for col in columns:
            self.observations_tree.heading(col, text=col)
            self.observations_tree.column(col, width=column_widths.get(col, 100), minwidth=50)
        
        # Scrollbars
        v_scrollbar = ttk.Scrollbar(table_frame, orient=tk.VERTICAL, command=self.observations_tree.yview)
        h_scrollbar = ttk.Scrollbar(table_frame, orient=tk.HORIZONTAL, command=self.observations_tree.xview)
        self.observations_tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Empaquetar tabla y scrollbars
        self.observations_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Configurar estilos alternados para las filas
        self.observations_tree.tag_configure('oddrow', background='#f0f0f0')
        self.observations_tree.tag_configure('evenrow', background='white')
    
    def create_footer(self, parent):
        """Crea el pie de p√°gina"""
        footer_frame = tk.Frame(parent, bg=self.colors.SURFACE_LIGHT, height=30)
        footer_frame.pack(fill=tk.X, pady=(10, 0))
        footer_frame.pack_propagate(False)
        
        # Barra de estado
        self.status_label = tk.Label(footer_frame,
                                    text="‚úÖ Sistema listo",
                                    font=("Arial", 9),
                                    fg=self.colors.TEXT_PRIMARY,
                                    bg=self.colors.SURFACE_LIGHT)
        self.status_label.pack(side=tk.LEFT, padx=15, pady=5)
    
    def get_role_info(self):
        """Obtiene informaci√≥n detallada del rol"""
        role_info = {
            'admin': "Administrador del sistema con acceso completo a todas las funciones.",
            'administrador': "Administrador del sistema con acceso completo a todas las funciones.",
            'supervisor': "Supervisor con permisos de edici√≥n y configuraci√≥n.",
            'operador': "Operador con permisos b√°sicos de visualizaci√≥n y creaci√≥n.",
            'tecnico': "T√©cnico con permisos de edici√≥n y visualizaci√≥n amplia.",
            'invitado': "Usuario invitado con permisos limitados de solo lectura."
        }
        return role_info.get(self.user_role, "Rol no definido")
    def get_role_display_name(self, role):
        """Obtiene el nombre de visualizaci√≥n del rol"""
        role_names = {
            'admin': 'Administrador',
            'administrador': 'Administrador', 
            'supervisor': 'Supervisor',
            'operador': 'Operador',
            'tecnico': 'T√©cnico',
            'invitado': 'Invitado'
        }
        return role_names.get(role, 'Usuario')
    
    def get_user_icon(self, role):
        """Obtiene el icono del usuario seg√∫n su rol"""
        role_icons = {
            'admin': 'üëë',
            'administrador': 'üëë',
            'supervisor': 'üë®‚Äçüíº', 
            'operador': 'üë∑',
            'tecnico': 'üîß',
            'invitado': 'üë§'
        }
        return role_icons.get(role, 'üë§')
    def show_user_profile(self):
        """Muestra el perfil del usuario actual"""
        profile_info = f"""üë§ Perfil de Usuario
        
üè∑Ô∏è Usuario: {self.user_name}
üé≠ Rol: {self.get_role_display_name(self.user_role)}
üìã Descripci√≥n: {self.get_role_info()}

üí° Tip: Tu rol determina qu√© funciones puedes usar en el sistema."""
        
        messagebox.showinfo("Perfil de Usuario", profile_info)
    def setup_menu(self):
        """Configura el men√∫ principal de la aplicaci√≥n"""
        # Crear barra de men√∫
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # Men√∫ Archivo
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="üìÅ Archivo", menu=file_menu)
        file_menu.add_command(label="üìä Exportar a Excel", command=self.export_to_excel)
        file_menu.add_separator()
        file_menu.add_command(label="üö™ Cerrar Sesi√≥n", command=self.handle_logout)
        file_menu.add_command(label="‚ùå Salir", command=self.close)
        
        # Men√∫ Ver
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="üëÅÔ∏è Ver", menu=view_menu)
        view_menu.add_command(label="üîÑ Actualizar", command=self.refresh_data)
        view_menu.add_command(label="üìà Estad√≠sticas", command=self.show_statistics)
        
        # Men√∫ Herramientas
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="üîß Herramientas", menu=tools_menu)
        tools_menu.add_command(label="‚öôÔ∏è Configuraci√≥n", command=self.show_config)
        tools_menu.add_command(label="üóëÔ∏è Limpiar Datos", command=self.clear_all_data)
        
        # Men√∫ Ayuda
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="‚ùì Ayuda", menu=help_menu)
        help_menu.add_command(label="‚ÑπÔ∏è Acerca de", command=self.show_about)
        help_menu.add_command(label="üìñ Manual", command=self.show_help)
    
    def export_to_excel(self):
        """Exporta los datos actuales a Excel"""
        try:
            # Implementar exportaci√≥n a Excel
            messagebox.showinfo("Exportar", "Funcionalidad de exportaci√≥n - Pr√≥ximamente disponible")
        except Exception as e:
            messagebox.showerror("Error", f"Error al exportar: {e}")
    
    def refresh_data(self):
        """Actualiza los datos mostrados"""
        try:
            self.load_observations()
            messagebox.showinfo("Actualizar", "Datos actualizados correctamente")
        except Exception as e:
            messagebox.showerror("Error", f"Error al actualizar: {e}")
    
    def show_statistics(self):
        """Muestra estad√≠sticas del sistema"""
        try:
            stats = self.db_manager.get_statistics()
            stats_text = f"""üìä Estad√≠sticas del Sistema
            
üìù Total de observaciones: {stats.get('total', 0)}
üè≠ M√°quinas registradas: {len(stats.get('por_maquina', {}))}
üë• Usuarios activos: {len(stats.get('por_usuario', {}))}
üìÖ √öltimo registro: {stats.get('ultima_fecha', 'N/A')}"""
            messagebox.showinfo("Estad√≠sticas", stats_text)
        except Exception as e:
            messagebox.showerror("Error", f"Error al obtener estad√≠sticas: {e}")
    
    def clear_all_data(self):
        """Limpia todos los datos (con confirmaci√≥n)"""
        result = messagebox.askyesno(
            "‚ö†Ô∏è Confirmar",
            "¬øEst√°s seguro de que quieres eliminar TODAS las observaciones?

‚ö†Ô∏è Esta acci√≥n NO se puede deshacer."
        )
        if result:
            try:
                self.db_manager.clear_all_observations()
                self.load_observations()
                messagebox.showinfo("√âxito", "Todos los datos han sido eliminados")
            except Exception as e:
                messagebox.showerror("Error", f"Error al limpiar datos: {e}")
    
    def show_about(self):
        """Muestra informaci√≥n sobre la aplicaci√≥n"""
        from version import get_full_version_string
        about_text = f"""üìä Sistema de Observaciones de M√°quinas
        
üè∑Ô∏è Versi√≥n: {get_full_version_string()}
üë§ Usuario: {self.user_name}
üé≠ Rol: {self.get_role_display_name(self.user_role)}
üíæ Base de datos: SQLite

¬© 2024 - Sistema de Gesti√≥n Industrial"""
        messagebox.showinfo("Acerca de", about_text)
    
    def show_help(self):
        """Muestra ayuda del sistema"""
        help_text = """üìñ Manual de Usuario
        
üîπ Crear observaci√≥n: Bot√≥n 'Nueva Observaci√≥n'
üîπ Filtrar datos: Usar los campos de filtro
üîπ Exportar: Men√∫ Archivo > Exportar a Excel
üîπ Estad√≠sticas: Men√∫ Ver > Estad√≠sticas

üí° Tip: Usa Ctrl+F para b√∫squeda r√°pida"""
        messagebox.showinfo("Ayuda", help_text)



    
    def show_welcome_message(self):
        """Muestra mensaje de bienvenida"""
        welcome_msg = f"¬°Bienvenido/a {self.user_name}!\n\nSistema de Observaciones de M√°quinas\n{get_full_version_string()}"
        messagebox.showinfo("Bienvenido", welcome_msg)
    
    def show_config(self):
        """Muestra ventana de configuraci√≥n"""
        messagebox.showinfo("Configuraci√≥n", "Ventana de configuraci√≥n - Pr√≥ximamente disponible")
    
    def handle_logout(self):
        """Maneja el cierre de sesi√≥n"""
        result = messagebox.askyesno(
            "Cerrar Sesi√≥n",
            f"¬øDeseas cerrar la sesi√≥n de {self.user_name}?"
        )
        if result:
            self.logout()
    
    def logout(self):
        """Cierra la sesi√≥n actual"""
        try:
            self.db_manager.close()
        except:
            pass
        
        if self.logout_callback:
            self.logout_callback()
        else:
            self.root.destroy()
    
    def on_window_close(self):
        """Maneja el cierre de la ventana"""
        result = messagebox.askyesno(
            "Salir",
            "¬øDeseas salir del programa?"
        )
        if result:
            self.close()
    
    def close(self):
        """Cierra la aplicaci√≥n"""
        try:
            self.db_manager.close()
        except:
            pass
        self.root.destroy()
    
    def show_new_incident_dialog(self):
        """Muestra di√°logo para nueva incidencia"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Nueva Observaci√≥n")
        
        # RESTAURAR comportamiento anterior - tama√±o fijo y centrado
        window_width, window_height = self.calculate_window_size(
            width_percent=0.25,   # M√°s peque√±o (25%)
            height_percent=0.35,  # M√°s peque√±o (35%)
            min_width=450,        # M√≠nimo m√°s peque√±o
            min_height=450,       # M√≠nimo m√°s peque√±o
            max_width=550,        # M√°ximo m√°s peque√±o
            max_height=550        # M√°ximo m√°s peque√±o
        )
        
        # Centrar respecto a la ventana principal
        self.center_window(dialog, window_width, window_height)
        
        # BLOQUEAR completamente - NO redimensionable
        dialog.resizable(False, False)
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Frame principal con MENOS padding vertical
        main_frame = tk.Frame(dialog, bg=self.colors.SURFACE_LIGHT, padx=15, pady=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # T√≠tulo
        title_label = tk.Label(main_frame, text="üìù Nueva Observaci√≥n", 
                              font=("Arial", 14, "bold"),
                              fg=self.colors.CORPORATE_GOLD,
                              bg=self.colors.BACKGROUND_PRIMARY)
        title_label.pack(pady=(0, 20))
        
        # ID autom√°tico (solo lectura)
        auto_id = tk.StringVar(value=str(self.db_manager.get_next_id()))
        tk.Label(main_frame, text="ID:", font=("Arial", 9, "bold"),
                fg=self.colors.TEXT_PRIMARY, bg=self.colors.BACKGROUND_PRIMARY).pack(anchor=tk.W, pady=(0, 2))
        id_entry = tk.Entry(main_frame, textvariable=auto_id, state='readonly', width=10, font=("Arial", 9))
        id_entry.pack(anchor=tk.W, pady=(2, 10))
        
        # Frame para campos en grid
        fields_frame = tk.Frame(main_frame, bg=self.colors.SURFACE_LIGHT)
        fields_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Fecha y Hora
        tk.Label(fields_frame, text="Fecha:", font=("Arial", 9, "bold"),
                fg=self.colors.TEXT_PRIMARY, bg=self.colors.SURFACE_LIGHT).grid(row=0, column=0, sticky="w", pady=2)
        selected_date = tk.StringVar(value=get_today_date())
        date_entry = DateEntry(fields_frame, textvariable=selected_date, width=12, 
                              background='darkblue', foreground='white', borderwidth=2, font=("Arial", 9))
        date_entry.grid(row=0, column=1, sticky="ew", padx=(5, 15), pady=2)
        
        tk.Label(fields_frame, text="Hora:", font=("Arial", 9, "bold"),
                fg=self.colors.TEXT_PRIMARY, bg=self.colors.SURFACE_LIGHT).grid(row=0, column=2, sticky="w", pady=2)
        selected_time = tk.StringVar(value=datetime.now().strftime("%H:%M"))
        time_entry = tk.Entry(fields_frame, textvariable=selected_time, width=8, font=("Arial", 9))
        time_entry.grid(row=0, column=3, sticky="ew", padx=(5, 0), pady=2)
    def show_complete_list(self):
        """Mostrar lista completa de observaciones"""
        try:
            # Usar DatabaseManager en lugar de ExcelManager
            observations = self.db_manager.get_all_observations()
            
            if not observations:
                messagebox.showinfo("Informaci√≥n", "No hay observaciones registradas.")
                return
            
            # Crear ventana para mostrar la lista completa
            list_window = tk.Toplevel(self.root)
            list_window.title("Lista Completa de Observaciones")
            list_window.geometry("1200x600")
            list_window.configure(bg=self.colors['bg'])
            
            # Crear frame principal con scrollbar
            main_frame = tk.Frame(list_window, bg=self.colors['bg'])
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Crear Treeview para mostrar los datos
            columns = ('ID', 'Fecha', 'Hora', 'M√°quina', 'Operador', 'Observaci√≥n', 'Acci√≥n', 'Estado')
            tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=20)
            
            # Configurar columnas
            tree.heading('ID', text='ID')
            tree.heading('Fecha', text='Fecha')
            tree.heading('Hora', text='Hora')
            tree.heading('M√°quina', text='M√°quina')
            tree.heading('Operador', text='Operador')
            tree.heading('Observaci√≥n', text='Observaci√≥n')
            tree.heading('Acci√≥n', text='Acci√≥n Tomada')
            tree.heading('Estado', text='Estado')
            
            # Ajustar ancho de columnas
            tree.column('ID', width=50)
            tree.column('Fecha', width=100)
            tree.column('Hora', width=80)
            tree.column('M√°quina', width=100)
            tree.column('Operador', width=100)
            tree.column('Observaci√≥n', width=300)
            tree.column('Acci√≥n', width=200)
            tree.column('Estado', width=100)
            
            # Insertar datos
            for obs in observations:
                tree.insert('', tk.END, values=(
                    obs.get('id', ''),
                    obs.get('fecha', ''),
                    obs.get('hora', ''),
                    obs.get('maquina', ''),
                    obs.get('operador', ''),
                    obs.get('observacion', ''),
                    obs.get('accion_tomada', ''),
                    obs.get('estado', '')
                ))
            
            # Scrollbars
            v_scrollbar = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=tree.yview)
            h_scrollbar = ttk.Scrollbar(main_frame, orient=tk.HORIZONTAL, command=tree.xview)
            tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
            
            # Posicionar elementos
            tree.grid(row=0, column=0, sticky='nsew')
            v_scrollbar.grid(row=0, column=1, sticky='ns')
            h_scrollbar.grid(row=1, column=0, sticky='ew')
            
            # Configurar grid weights
            main_frame.grid_rowconfigure(0, weight=1)
            main_frame.grid_columnconfigure(0, weight=1)
            
            # Frame para botones
            button_frame = tk.Frame(list_window, bg=self.colors['bg'])
            button_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
            
            # Bot√≥n para exportar a Excel
            export_btn = tk.Button(
                button_frame,
                text="Exportar a Excel",
                command=lambda: self.export_to_excel(observations),
                bg=self.colors['button'],
                fg=self.colors['button_text'],
                font=('Arial', 10),
                relief=tk.FLAT,
                padx=20,
                pady=5
            )
            export_btn.pack(side=tk.LEFT, padx=(0, 10))
            
            # Bot√≥n cerrar
            close_btn = tk.Button(
                button_frame,
                text="Cerrar",
                command=list_window.destroy,
                bg=self.colors['secondary'],
                fg=self.colors['button_text'],
                font=('Arial', 10),
                relief=tk.FLAT,
                padx=20,
                pady=5
            )
            close_btn.pack(side=tk.RIGHT)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al mostrar la lista completa: {str(e)}")
    
    def export_to_excel(self, observations):
        """Exportar observaciones a Excel"""
        try:
            from tkinter import filedialog
            import pandas as pd
            from datetime import datetime
            
            # Solicitar ubicaci√≥n del archivo
            filename = filedialog.asksaveasfilename(
                defaultextension=".xlsx",
                filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")],
                title="Guardar como Excel"
            )
            
            if filename:
                # Convertir observaciones a DataFrame
                df = pd.DataFrame(observations)
                
                # Guardar a Excel
                df.to_excel(filename, index=False, sheet_name='Observaciones')
                
                messagebox.showinfo("√âxito", f"Datos exportados correctamente a {filename}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Error al exportar a Excel: {str(e)}")
    
    def load_today_observations(self):
        """Cargar observaciones del d√≠a actual"""
        try:
            from datetime import date
            today = date.today().strftime('%Y-%m-%d')
            
            # Usar DatabaseManager para obtener observaciones por fecha
            observations = self.db_manager.get_observations_by_date(today)
            
            # Limpiar lista actual
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            # Cargar observaciones del d√≠a
            for obs in observations:
                self.tree.insert('', tk.END, values=(
                    obs.get('id', ''),
                    obs.get('fecha', ''),
                    obs.get('hora', ''),
                    obs.get('maquina', ''),
                    obs.get('operador', ''),
                    obs.get('observacion', ''),
                    obs.get('accion_tomada', ''),
                    obs.get('estado', '')
                ))
            
            # Actualizar contador
            self.update_observation_count()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al cargar observaciones del d√≠a: {str(e)}")
    
    def apply_filters(self):
        """Aplicar filtros a las observaciones"""
        try:
            # Obtener valores de filtros
            fecha_desde = self.fecha_desde_var.get() if hasattr(self, 'fecha_desde_var') else None
            fecha_hasta = self.fecha_hasta_var.get() if hasattr(self, 'fecha_hasta_var') else None
            maquina_filter = self.maquina_filter_var.get() if hasattr(self, 'maquina_filter_var') else None
            operador_filter = self.operador_filter_var.get() if hasattr(self, 'operador_filter_var') else None
            estado_filter = self.estado_filter_var.get() if hasattr(self, 'estado_filter_var') else None
            
            # Crear diccionario de filtros
            filters = {}
            if fecha_desde:
                filters['fecha_desde'] = fecha_desde
            if fecha_hasta:
                filters['fecha_hasta'] = fecha_hasta
            if maquina_filter and maquina_filter != "Todas":
                filters['maquina'] = maquina_filter
            if operador_filter and operador_filter != "Todos":
                filters['operador'] = operador_filter
            if estado_filter and estado_filter != "Todos":
                filters['estado'] = estado_filter
            
            # Aplicar filtros usando DatabaseManager
            observations = self.db_manager.filter_observations(**filters)
            
            # Limpiar lista actual
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            # Cargar observaciones filtradas
            for obs in observations:
                self.tree.insert('', tk.END, values=(
                    obs.get('id', ''),
                    obs.get('fecha', ''),
                    obs.get('hora', ''),
                    obs.get('maquina', ''),
                    obs.get('operador', ''),
                    obs.get('observacion', ''),
                    obs.get('accion_tomada', ''),
                    obs.get('estado', '')
                ))
            
            # Actualizar contador
            self.update_observation_count()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al aplicar filtros: {str(e)}")
    
    def clear_filters(self):
        """Limpiar todos los filtros"""
        try:
            # Limpiar variables de filtros
            if hasattr(self, 'fecha_desde_var'):
                self.fecha_desde_var.set('')
            if hasattr(self, 'fecha_hasta_var'):
                self.fecha_hasta_var.set('')
            if hasattr(self, 'maquina_filter_var'):
                self.maquina_filter_var.set('Todas')
            if hasattr(self, 'operador_filter_var'):
                self.operador_filter_var.set('Todos')
            if hasattr(self, 'estado_filter_var'):
                self.estado_filter_var.set('Todos')
            
            # Recargar todas las observaciones
            self.load_all_observations()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al limpiar filtros: {str(e)}")
    
    def load_all_observations(self):
        """Cargar todas las observaciones"""
        try:
            # Obtener todas las observaciones usando DatabaseManager
            observations = self.db_manager.get_all_observations()
            
            # Limpiar lista actual
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            # Cargar todas las observaciones
            for obs in observations:
                self.tree.insert('', tk.END, values=(
                    obs.get('id', ''),
                    obs.get('fecha', ''),
                    obs.get('hora', ''),
                    obs.get('maquina', ''),
                    obs.get('operador', ''),
                    obs.get('observacion', ''),
                    obs.get('accion_tomada', ''),
                    obs.get('estado', '')
                ))
            
            # Actualizar contador
            self.update_observation_count()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al cargar observaciones: {str(e)}")
    
    def search_observations(self, search_term):
        """Buscar observaciones por t√©rmino"""
        try:
            if not search_term.strip():
                self.load_all_observations()
                return
            
            # Buscar usando DatabaseManager
            observations = self.db_manager.search_observations(search_term)
            
            # Limpiar lista actual
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            # Cargar observaciones encontradas
            for obs in observations:
                self.tree.insert('', tk.END, values=(
                    obs.get('id', ''),
                    obs.get('fecha', ''),
                    obs.get('hora', ''),
                    obs.get('maquina', ''),
                    obs.get('operador', ''),
                    obs.get('observacion', ''),
                    obs.get('accion_tomada', ''),
                    obs.get('estado', '')
                ))
            
            # Actualizar contador
            self.update_observation_count()
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al buscar observaciones: {str(e)}")
    
    def update_observation_count(self):
        """Actualizar contador de observaciones"""
        try:
            count = len(self.tree.get_children())
            if hasattr(self, 'count_label'):
                self.count_label.config(text=f"Total: {count} observaciones")
        except Exception as e:
            print(f"Error al actualizar contador: {str(e)}")
    
    def show_statistics(self):
        """Mostrar estad√≠sticas de observaciones"""
        try:
            # Obtener estad√≠sticas usando DatabaseManager
            stats = self.db_manager.get_statistics()
            
            if not stats:
                messagebox.showinfo("Informaci√≥n", "No hay datos suficientes para mostrar estad√≠sticas.")
                return
            
            # Crear ventana de estad√≠sticas
            stats_window = tk.Toplevel(self.root)
            stats_window.title("Estad√≠sticas de Observaciones")
            stats_window.geometry("600x500")
            stats_window.configure(bg=self.colors['bg'])
            
            # Frame principal
            main_frame = tk.Frame(stats_window, bg=self.colors['bg'])
            main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
            
            # T√≠tulo
            title_label = tk.Label(
                main_frame,
                text="üìä Estad√≠sticas de Observaciones",
                font=('Arial', 16, 'bold'),
                bg=self.colors['bg'],
                fg=self.colors['text']
            )
            title_label.pack(pady=(0, 20))
            
            # Estad√≠sticas generales
            general_frame = tk.LabelFrame(
                main_frame,
                text="Estad√≠sticas Generales",
                font=('Arial', 12, 'bold'),
                bg=self.colors['bg'],
                fg=self.colors['text']
            )
            general_frame.pack(fill=tk.X, pady=(0, 15))
            
            # Total de observaciones
            total_label = tk.Label(
                general_frame,
                text=f"Total de observaciones: {stats.get('total_observaciones', 0)}",
                font=('Arial', 11),
                bg=self.colors['bg'],
                fg=self.colors['text']
            )
            total_label.pack(anchor='w', padx=10, pady=5)
            
            # Observaciones por estado
            if 'por_estado' in stats:
                estado_frame = tk.LabelFrame(
                    main_frame,
                    text="Por Estado",
                    font=('Arial', 12, 'bold'),
                    bg=self.colors['bg'],
                    fg=self.colors['text']
                )
                estado_frame.pack(fill=tk.X, pady=(0, 15))
                
                for estado, count in stats['por_estado'].items():
                    estado_label = tk.Label(
                        estado_frame,
                        text=f"{estado}: {count}",
                        font=('Arial', 11),
                        bg=self.colors['bg'],
                        fg=self.colors['text']
                    )
                    estado_label.pack(anchor='w', padx=10, pady=2)
            
            # Observaciones por m√°quina
            if 'por_maquina' in stats:
                maquina_frame = tk.LabelFrame(
                    main_frame,
                    text="Por M√°quina",
                    font=('Arial', 12, 'bold'),
                    bg=self.colors['bg'],
                    fg=self.colors['text']
                )
                maquina_frame.pack(fill=tk.X, pady=(0, 15))
                
                for maquina, count in stats['por_maquina'].items():
                    maquina_label = tk.Label(
                        maquina_frame,
                        text=f"{maquina}: {count}",
                        font=('Arial', 11),
                        bg=self.colors['bg'],
                        fg=self.colors['text']
                    )
                    maquina_label.pack(anchor='w', padx=10, pady=2)
            
            # Bot√≥n cerrar
            close_btn = tk.Button(
                main_frame,
                text="Cerrar",
                command=stats_window.destroy,
                bg=self.colors['button'],
                fg=self.colors['button_text'],
                font=('Arial', 11),
                relief=tk.FLAT,
                padx=30,
                pady=8
            )
            close_btn.pack(pady=20)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al mostrar estad√≠sticas: {str(e)}")
    def show_admin_console(self):
        """Mostrar consola de administraci√≥n"""
        try:
            # Crear ventana de administraci√≥n
            admin_window = tk.Toplevel(self.root)
            admin_window.title("Consola de Administraci√≥n")
            admin_window.geometry("800x600")
            admin_window.configure(bg=self.colors['bg'])
            
            # Frame principal
            main_frame = tk.Frame(admin_window, bg=self.colors['bg'])
            main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
            
            # T√≠tulo
            title_label = tk.Label(
                main_frame,
                text="üîß Consola de Administraci√≥n",
                font=('Arial', 16, 'bold'),
                bg=self.colors['bg'],
                fg=self.colors['text']
            )
            title_label.pack(pady=(0, 20))
            
            # Informaci√≥n de la base de datos
            db_frame = tk.LabelFrame(
                main_frame,
                text="Informaci√≥n de Base de Datos",
                font=('Arial', 12, 'bold'),
                bg=self.colors['bg'],
                fg=self.colors['text']
            )
            db_frame.pack(fill=tk.X, pady=(0, 15))
            
            # Ruta de la base de datos
            db_path_label = tk.Label(
                db_frame,
                text=f"Base de datos: {self.db_manager.db_path}",
                font=('Arial', 11),
                bg=self.colors['bg'],
                fg=self.colors['text']
            )
            db_path_label.pack(anchor='w', padx=10, pady=5)
            
            # Estad√≠sticas r√°pidas
            try:
                stats = self.db_manager.get_statistics()
                total_obs = stats.get('total_observaciones', 0)
                stats_label = tk.Label(
                    db_frame,
                    text=f"Total de observaciones: {total_obs}",
                    font=('Arial', 11),
                    bg=self.colors['bg'],
                    fg=self.colors['text']
                )
                stats_label.pack(anchor='w', padx=10, pady=2)
            except Exception as e:
                error_label = tk.Label(
                    db_frame,
                    text=f"Error al obtener estad√≠sticas: {str(e)}",
                    font=('Arial', 11),
                    bg=self.colors['bg'],
                    fg='red'
                )
                error_label.pack(anchor='w', padx=10, pady=2)
            
            # Frame de acciones
            actions_frame = tk.LabelFrame(
                main_frame,
                text="Acciones de Base de Datos",
                font=('Arial', 12, 'bold'),
                bg=self.colors['bg'],
                fg=self.colors['text']
            )
            actions_frame.pack(fill=tk.X, pady=(0, 15))
            
            # Botones de acciones
            button_frame = tk.Frame(actions_frame, bg=self.colors['bg'])
            button_frame.pack(fill=tk.X, padx=10, pady=10)
            
            # Bot√≥n para crear backup
            backup_btn = tk.Button(
                button_frame,
                text="Crear Backup",
                command=self.create_database_backup,
                bg=self.colors['button'],
                fg=self.colors['button_text'],
                font=('Arial', 10),
                relief=tk.FLAT,
                padx=15,
                pady=5
            )
            backup_btn.pack(side=tk.LEFT, padx=(0, 10))
            
            # Bot√≥n para exportar a Excel
            export_btn = tk.Button(
                button_frame,
                text="Exportar Todo a Excel",
                command=self.export_all_to_excel,
                bg=self.colors['button'],
                fg=self.colors['button_text'],
                font=('Arial', 10),
                relief=tk.FLAT,
                padx=15,
                pady=5
            )
            export_btn.pack(side=tk.LEFT, padx=(0, 10))
            
            # Bot√≥n para optimizar base de datos
            optimize_btn = tk.Button(
                button_frame,
                text="Optimizar BD",
                command=self.optimize_database,
                bg=self.colors['secondary'],
                fg=self.colors['button_text'],
                font=('Arial', 10),
                relief=tk.FLAT,
                padx=15,
                pady=5
            )
            optimize_btn.pack(side=tk.LEFT, padx=(0, 10))
            
            # Frame para consultas SQL personalizadas
            sql_frame = tk.LabelFrame(
                main_frame,
                text="Consulta SQL Personalizada",
                font=('Arial', 12, 'bold'),
                bg=self.colors['bg'],
                fg=self.colors['text']
            )
            sql_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
            
            # √Årea de texto para SQL
            sql_text = tk.Text(
                sql_frame,
                height=8,
                font=('Consolas', 10),
                bg='white',
                fg='black'
            )
            sql_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Bot√≥n para ejecutar SQL
            execute_btn = tk.Button(
                sql_frame,
                text="Ejecutar Consulta",
                command=lambda: self.execute_custom_sql(sql_text.get('1.0', tk.END)),
                bg=self.colors['accent'],
                fg=self.colors['button_text'],
                font=('Arial', 10),
                relief=tk.FLAT,
                padx=20,
                pady=5
            )
            execute_btn.pack(pady=(0, 10))
            
            # Bot√≥n cerrar
            close_btn = tk.Button(
                main_frame,
                text="Cerrar",
                command=admin_window.destroy,
                bg=self.colors['button'],
                fg=self.colors['button_text'],
                font=('Arial', 11),
                relief=tk.FLAT,
                padx=30,
                pady=8
            )
            close_btn.pack(pady=10)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al mostrar consola de administraci√≥n: {str(e)}")
    
    def create_database_backup(self):
        """Crear backup de la base de datos"""
        try:
            from tkinter import filedialog
            from datetime import datetime
            import shutil
            
            # Solicitar ubicaci√≥n del backup
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            default_name = f"backup_observaciones_{timestamp}.db"
            
            backup_path = filedialog.asksaveasfilename(
                defaultextension=".db",
                filetypes=[("SQLite Database", "*.db"), ("All files", "*.*")],
                title="Guardar Backup",
                initialvalue=default_name
            )
            
            if backup_path:
                # Crear backup usando DatabaseManager
                success = self.db_manager.create_backup(backup_path)
                
                if success:
                    messagebox.showinfo("√âxito", f"Backup creado correctamente en:\n{backup_path}")
                else:
                    messagebox.showerror("Error", "Error al crear el backup")
                    
        except Exception as e:
            messagebox.showerror("Error", f"Error al crear backup: {str(e)}")
    
    def export_all_to_excel(self):
        """Exportar todas las observaciones a Excel"""
        try:
            # Obtener todas las observaciones
            observations = self.db_manager.get_all_observations()
            
            if not observations:
                messagebox.showinfo("Informaci√≥n", "No hay observaciones para exportar.")
                return
            
            # Usar el m√©todo de exportaci√≥n existente
            self.export_to_excel(observations)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al exportar a Excel: {str(e)}")
    
    def optimize_database(self):
        """Optimizar la base de datos"""
        try:
            # Confirmar acci√≥n
            result = messagebox.askyesno(
                "Confirmar",
                "¬øDesea optimizar la base de datos?\n\nEsto puede tomar unos momentos."
            )
            
            if result:
                # Optimizar usando DatabaseManager
                success = self.db_manager.optimize_database()
                
                if success:
                    messagebox.showinfo("√âxito", "Base de datos optimizada correctamente.")
                else:
                    messagebox.showerror("Error", "Error al optimizar la base de datos.")
                    
        except Exception as e:
            messagebox.showerror("Error", f"Error al optimizar base de datos: {str(e)}")
    
    def execute_custom_sql(self, sql_query):
        """Ejecutar consulta SQL personalizada"""
        try:
            sql_query = sql_query.strip()
            if not sql_query:
                messagebox.showwarning("Advertencia", "Por favor ingrese una consulta SQL.")
                return
            
            # Ejecutar consulta usando DatabaseManager
            result = self.db_manager.execute_custom_query(sql_query)
            
            if result is not None:
                # Mostrar resultados en una nueva ventana
                self.show_sql_results(result, sql_query)
            else:
                messagebox.showinfo("Informaci√≥n", "Consulta ejecutada correctamente (sin resultados).")
                
        except Exception as e:
            messagebox.showerror("Error SQL", f"Error al ejecutar consulta:\n{str(e)}")
    
    def show_sql_results(self, results, query):
        """Mostrar resultados de consulta SQL"""
        try:
            # Crear ventana para resultados
            results_window = tk.Toplevel(self.root)
            results_window.title("Resultados de Consulta SQL")
            results_window.geometry("800x500")
            results_window.configure(bg=self.colors['bg'])
            
            # Frame principal
            main_frame = tk.Frame(results_window, bg=self.colors['bg'])
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Mostrar consulta ejecutada
            query_label = tk.Label(
                main_frame,
                text=f"Consulta: {query[:100]}{'...' if len(query) > 100 else ''}",
                font=('Arial', 10),
                bg=self.colors['bg'],
                fg=self.colors['text']
            )
            query_label.pack(anchor='w', pady=(0, 10))
            
            if results:
                # Crear Treeview para mostrar resultados
                if isinstance(results[0], dict):
                    columns = list(results[0].keys())
                else:
                    columns = [f"Columna_{i+1}" for i in range(len(results[0]))]
                
                tree = ttk.Treeview(main_frame, columns=columns, show='headings', height=15)
                
                # Configurar columnas
                for col in columns:
                    tree.heading(col, text=col)
                    tree.column(col, width=100)
                
                # Insertar datos
                for row in results:
                    if isinstance(row, dict):
                        values = [row.get(col, '') for col in columns]
                    else:
                        values = row
                    tree.insert('', tk.END, values=values)
                
                # Scrollbars
                v_scrollbar = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=tree.yview)
                h_scrollbar = ttk.Scrollbar(main_frame, orient=tk.HORIZONTAL, command=tree.xview)
                tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
                
                # Posicionar elementos
                tree.grid(row=0, column=0, sticky='nsew')
                v_scrollbar.grid(row=0, column=1, sticky='ns')
                h_scrollbar.grid(row=1, column=0, sticky='ew')
                
                # Configurar grid weights
                main_frame.grid_rowconfigure(0, weight=1)
                main_frame.grid_columnconfigure(0, weight=1)
                
            else:
                no_results_label = tk.Label(
                    main_frame,
                    text="No se encontraron resultados.",
                    font=('Arial', 12),
                    bg=self.colors['bg'],
                    fg=self.colors['text']
                )
                no_results_label.pack(expand=True)
            
            # Bot√≥n cerrar
            close_btn = tk.Button(
                results_window,
                text="Cerrar",
                command=results_window.destroy,
                bg=self.colors['button'],
                fg=self.colors['button_text'],
                font=('Arial', 10),
                relief=tk.FLAT,
                padx=20,
                pady=5
            )
            close_btn.pack(pady=10)
            
        except Exception as e:
            messagebox.showerror("Error", f"Error al mostrar resultados: {str(e)}")
    
    def clear_all_observations(self):
        """Limpiar todas las observaciones (solo para administradores)"""
        try:
            # Confirmar acci√≥n m√∫ltiple
            result = messagebox.askyesno(
                "‚ö†Ô∏è ADVERTENCIA",
                "¬øEst√° seguro de que desea ELIMINAR TODAS las observaciones?\n\n"
                "Esta acci√≥n NO se puede deshacer.\n\n"
                "Se recomienda crear un backup antes de continuar."
            )
            
            if result:
                # Segunda confirmaci√≥n
                second_result = messagebox.askyesno(
                    "‚ö†Ô∏è CONFIRMACI√ìN FINAL",
                    "√öLTIMA ADVERTENCIA:\n\n"
                    "Se eliminar√°n TODAS las observaciones de la base de datos.\n\n"
                    "¬øContinuar?"
                )
                
                if second_result:
                    # Eliminar todas las observaciones usando DatabaseManager
                    success = self.db_manager.clear_all_observations()
                    
                    if success:
                        messagebox.showinfo("√âxito", "Todas las observaciones han sido eliminadas.")
                        # Recargar la vista
                        self.load_all_observations()
                    else:
                        messagebox.showerror("Error", "Error al eliminar las observaciones.")
                        
        except Exception as e:
            messagebox.showerror("Error", f"Error al limpiar observaciones: {str(e)}")
    
    def on_closing(self):
        """Manejar el cierre de la aplicaci√≥n"""
        try:
            # Cerrar conexi√≥n a la base de datos
            if hasattr(self, 'db_manager'):
                self.db_manager.close()
            
            # Cerrar la aplicaci√≥n
            self.root.quit()
            self.root.destroy()
            
        except Exception as e:
            print(f"Error al cerrar la aplicaci√≥n: {str(e)}")
            self.root.quit()
            self.root.destroy()

